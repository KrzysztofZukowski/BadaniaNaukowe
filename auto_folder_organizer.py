# auto_folder_organizer.py - NAPRAWIONA wersja z uproszczonymi kategoriami
import os
import shutil
import re
from datetime import datetime
from collections import defaultdict, Counter
from tkinter import messagebox
import traceback


class AutoFolderOrganizer:
    """Klasa do automatycznego organizowania plik√≥w w hierarchicznej strukturze folder√≥w"""

    def __init__(self, category_analyzer):
        self.category_analyzer = category_analyzer

        # UPROSZCZONE mapowanie kategorii - tylko rozszerzenia
        self.main_folder_mapping = {
            'dokumenty_tekstowe': 'üìÑ Dokumenty',
            'dokumenty_pdf': 'üìÑ Dokumenty',
            'arkusze_kalkulacyjne': 'üìä Arkusze i Dane',
            'prezentacje': 'üìä Arkusze i Dane',
            'obrazy_zdjecia': 'üñºÔ∏è Zdjƒôcia i Obrazy',
            'obrazy_wektorowe': 'üé® Grafika',
            'audio_muzyka': 'üéµ Audio',
            'audio_podcasty': 'üéµ Audio',
            'wideo': 'üé¨ Video',
            'archiwa': 'üì¶ Archiwa',
            'kod_skrypty': 'üíª Kod i Programy',
            'bazy_danych': 'üíæ Bazy Danych',
            'wykonywalne': 'üíª Kod i Programy',
            'projekty_graficzne': 'üé® Grafika',
            'projekty_inne': 'üîß Projekty',
            'ebooki': 'üìö KsiƒÖ≈ºki',
            'czcionki': 'üî§ Czcionki',
            'pliki_konfiguracyjne': '‚öôÔ∏è Konfiguracja',
            'animacje': 'üéûÔ∏è Animacje',
            'pliki_3d': 'üéØ Pliki 3D',
            'wirtualizacja': 'üíø Wirtualizacja',
            'konfiguracja_systemu': '‚öôÔ∏è Konfiguracja',
            'pliki_office': 'üìÑ Dokumenty',
            'mapy_dane_przestrzenne': 'üó∫Ô∏è Mapy',
            'nieznana': '‚ùì Inne'
        }

        # NOWE: Mapowanie dynamicznych kategorii
        self.dynamic_folder_mapping = {
            'backup': 'Kopie Zapasowe',
            'config': 'Konfiguracja',
            'temp': 'Pliki Tymczasowe',
            'test': 'Pliki Testowe'
        }

    def generate_folder_structure(self, base_path, files_info_list, organization_mode="full"):
        """
        Generuje strukturƒô folder√≥w na podstawie listy plik√≥w
        """
        print(f"\n=== GENEROWANIE STRUKTURY FOLDER√ìW ===")
        print(f"Tryb organizacji: {organization_mode}")
        print(f"≈öcie≈ºka bazowa: {base_path}")
        print(f"Liczba plik√≥w: {len(files_info_list)}")

        file_mapping = {}
        folder_stats = defaultdict(int)

        for file_info in files_info_list:
            try:
                # Generuj ≈õcie≈ºkƒô dla tego pliku
                target_path = self._generate_file_path(base_path, file_info, organization_mode)

                # Dodaj do mapowania
                source_path = file_info.source_path
                file_mapping[source_path] = target_path

                # Aktualizuj statystyki folder√≥w
                folder_path = os.path.dirname(target_path)
                folder_stats[folder_path] += 1

                print(f"  {file_info.name}{file_info.extension} -> {os.path.relpath(target_path, base_path)}")

            except Exception as e:
                print(f"B≈ÇƒÖd generowania ≈õcie≈ºki dla {file_info.name}: {e}")
                traceback.print_exc()
                continue

        # Wy≈õwietl statystyki
        print(f"\n=== STATYSTYKI STRUKTURY ===")
        print(f"Wygenerowano mapowanie dla {len(file_mapping)} plik√≥w")
        print(f"Liczba unikalnych folder√≥w: {len(folder_stats)}")

        # Poka≈º najwiƒôksze foldery
        top_folders = sorted(folder_stats.items(), key=lambda x: x[1], reverse=True)[:10]
        for folder, count in top_folders:
            rel_path = os.path.relpath(folder, base_path)
            print(f"  {rel_path}: {count} plik√≥w")

        return file_mapping

    def generate_folder_structure_custom(self, base_path, files_info_list, hierarchy_levels):
        """
        Generuje strukturƒô folder√≥w na podstawie niestandardowej hierarchii
        """
        print(f"\n=== GENEROWANIE STRUKTURY FOLDER√ìW (CUSTOM) ===")
        print(f"Hierarchia: {' -> '.join(hierarchy_levels)}")
        print(f"≈öcie≈ºka bazowa: {base_path}")
        print(f"Liczba plik√≥w: {len(files_info_list)}")

        file_mapping = {}
        folder_stats = defaultdict(int)

        for file_info in files_info_list:
            try:
                # Generuj ≈õcie≈ºkƒô dla tego pliku u≈ºywajƒÖc custom hierarchii
                target_path = self._generate_file_path_custom(base_path, file_info, hierarchy_levels)

                # Dodaj do mapowania
                source_path = file_info.source_path
                file_mapping[source_path] = target_path

                # Aktualizuj statystyki folder√≥w
                folder_path = os.path.dirname(target_path)
                folder_stats[folder_path] += 1

                print(f"  {file_info.name}{file_info.extension} -> {os.path.relpath(target_path, base_path)}")

            except Exception as e:
                print(f"B≈ÇƒÖd generowania ≈õcie≈ºki dla {file_info.name}: {e}")
                traceback.print_exc()
                continue

        # Wy≈õwietl statystyki
        print(f"\n=== STATYSTYKI STRUKTURY ===")
        print(f"Wygenerowano mapowanie dla {len(file_mapping)} plik√≥w")
        print(f"Liczba unikalnych folder√≥w: {len(folder_stats)}")

        # Poka≈º najwiƒôksze foldery
        top_folders = sorted(folder_stats.items(), key=lambda x: x[1], reverse=True)[:10]
        for folder, count in top_folders:
            rel_path = os.path.relpath(folder, base_path)
            print(f"  {rel_path}: {count} plik√≥w")

        return file_mapping

    def _sanitize_folder_name(self, name):
        """Sanityzuje nazwƒô folderu dla Windows - usuwa niedozwolone znaki"""
        if not name:
            return "Inne"

        # Niedozwolone znaki w Windows: < > : " | ? * /  oraz znaki kontrolne
        forbidden_chars = '<>:"|?*/'

        # ZastƒÖp niedozwolone znaki
        sanitized = name
        for char in forbidden_chars:
            sanitized = sanitized.replace(char, ' ')

        # Usu≈Ñ podw√≥jne spacje
        while '  ' in sanitized:
            sanitized = sanitized.replace('  ', ' ')

        # Usu≈Ñ spacje z poczƒÖtku i ko≈Ñca
        sanitized = sanitized.strip()

        # Sprawd≈∫ d≈Çugo≈õƒá (Windows ma limit ~255 znak√≥w, ale bezpieczniej 100)
        if len(sanitized) > 100:
            sanitized = sanitized[:100].strip()

        # Nie mo≈ºe byƒá puste po sanityzacji
        if not sanitized:
            sanitized = "Inne"

        # Nie mo≈ºe ko≈Ñczyƒá siƒô kropkƒÖ (Windows)
        if sanitized.endswith('.'):
            sanitized = sanitized.rstrip('.').strip()
            if not sanitized:
                sanitized = "Inne"

        return sanitized

    def _generate_file_path(self, base_path, file_info, organization_mode):
        """Generuje pe≈ÇnƒÖ ≈õcie≈ºkƒô dla pojedynczego pliku - NAPRAWIONA wersja dla Windows"""
        path_components = [base_path]

        if organization_mode == "simple":
            # Tylko typ pliku
            main_folder = self._sanitize_folder_name(self._get_main_folder(file_info))
            path_components.append(main_folder)

        elif organization_mode == "by_date":
            # Typ pliku + data
            main_folder = self._sanitize_folder_name(self._get_main_folder(file_info))
            date_folder = self._sanitize_folder_name(self._get_date_folder(file_info))
            path_components.extend([main_folder, date_folder])

        elif organization_mode == "full":
            # Typ pliku + data + dynamiczna kategoria
            main_folder = self._sanitize_folder_name(self._get_main_folder(file_info))
            date_folder = self._sanitize_folder_name(self._get_date_folder(file_info))
            dynamic_folder = self._get_dynamic_folder(file_info)
            if dynamic_folder:
                dynamic_folder = self._sanitize_folder_name(dynamic_folder)

            path_components.append(main_folder)
            if date_folder:
                path_components.append(date_folder)
            if dynamic_folder:
                path_components.append(dynamic_folder)

        elif organization_mode == "theme_first":
            # Dynamiczna kategoria + typ pliku + data
            dynamic_folder = self._get_dynamic_folder(file_info)
            if dynamic_folder:
                dynamic_folder = self._sanitize_folder_name(dynamic_folder)
            main_folder = self._sanitize_folder_name(self._get_main_folder(file_info))
            date_folder = self._sanitize_folder_name(self._get_date_folder(file_info))

            if dynamic_folder:
                path_components.append(dynamic_folder)
            path_components.append(main_folder)
            if date_folder:
                path_components.append(date_folder)

        # Utw√≥rz ≈õcie≈ºkƒô folderu - u≈ºywaj os.path.join dla w≈Ça≈õciwych separator√≥w
        folder_path = os.path.join(*path_components)

        # Dodaj nazwƒô pliku - sanityzuj te≈º nazwƒô pliku
        safe_filename = self._sanitize_filename(f"{file_info.name}{file_info.extension}")
        file_path = os.path.join(folder_path, safe_filename)

        return file_path

    def _generate_file_path_custom(self, base_path, file_info, hierarchy_levels):
        """Generuje pe≈ÇnƒÖ ≈õcie≈ºkƒô dla pliku u≈ºywajƒÖc niestandardowej hierarchii"""
        path_components = [base_path]

        # Przejd≈∫ przez ka≈ºdy poziom hierarchii
        for level in hierarchy_levels:
            folder_name = None

            if level == "type":
                # Typ pliku (dokumenty, obrazy, etc.)
                folder_name = self._get_main_folder(file_info)

            elif level == "extension":
                # Rozszerzenie pliku
                ext = file_info.extension.lower() if file_info.extension else "brak_rozszerzenia"
                folder_name = f"Rozszerzenie {ext}"

            elif level == "date":
                # Data
                folder_name = self._get_date_folder(file_info)

            elif level == "size":
                # Rozmiar
                folder_name = f"Rozmiar {file_info.size_category}"

            elif level == "dynamic":
                # Dynamiczne kategorie
                folder_name = self._get_dynamic_folder(file_info)
                if not folder_name:
                    # Je≈õli brak dynamicznej kategorii, pomi≈Ñ ten poziom
                    continue

            # Dodaj folder do ≈õcie≈ºki (je≈õli istnieje)
            if folder_name:
                folder_name = self._sanitize_folder_name(folder_name)
                path_components.append(folder_name)

        # Utw√≥rz ≈õcie≈ºkƒô folderu
        folder_path = os.path.join(*path_components)

        # Dodaj nazwƒô pliku
        safe_filename = self._sanitize_filename(f"{file_info.name}{file_info.extension}")
        file_path = os.path.join(folder_path, safe_filename)

        return file_path

    def _sanitize_filename(self, filename):
        """Sanityzuje nazwƒô pliku dla Windows"""
        if not filename:
            return "plik.txt"

        # Niedozwolone znaki w nazwach plik√≥w Windows
        forbidden_chars = '<>:"|?*'

        sanitized = filename
        for char in forbidden_chars:
            sanitized = sanitized.replace(char, '_')

        # Nie mo≈ºe ko≈Ñczyƒá siƒô spacjƒÖ ani kropkƒÖ
        sanitized = sanitized.rstrip(' .')

        # Sprawd≈∫ d≈Çugo≈õƒá
        if len(sanitized) > 200:  # Bezpieczny limit
            name, ext = os.path.splitext(sanitized)
            sanitized = name[:200 - len(ext)] + ext

        return sanitized if sanitized else "plik.txt"

    def _get_main_folder(self, file_info):
        """Zwraca nazwƒô g≈Ç√≥wnego folderu na podstawie typu pliku"""
        category = file_info.category_extension
        return self.main_folder_mapping.get(category, '‚ùì Inne')

    def _get_date_folder(self, file_info):
        """Zwraca nazwƒô folderu daty"""
        try:
            # Spr√≥buj sparsowaƒá datƒô utworzenia
            if file_info.creation_date and file_info.creation_date != "Nieznany":
                # Format daty: YYYY-MM-DD HH:MM:SS
                date_str = file_info.creation_date.split()[0]  # We≈∫ tylko czƒô≈õƒá z datƒÖ
                date_obj = datetime.strptime(date_str, '%Y-%m-%d')

                # Zwr√≥ƒá rok i miesiƒÖc
                return f"{date_obj.year}/{date_obj.strftime('%m - %B')}"

            # Fallback na datƒô modyfikacji
            elif file_info.modification_date and file_info.modification_date != "Nieznany":
                date_str = file_info.modification_date.split()[0]
                date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                return f"{date_obj.year}/{date_obj.strftime('%m - %B')}"

        except Exception as e:
            print(f"B≈ÇƒÖd parsowania daty dla {file_info.name}: {e}")

        # Fallback na kategoriƒô daty z analizatora
        date_category = getattr(file_info, 'date_category', 'nieznana')
        date_mapping = {
            'dzisiaj': 'Najnowsze/Dzisiaj',
            'ostatni_tydzie≈Ñ': 'Najnowsze/Ostatni tydzie≈Ñ',
            'ostatni_miesiƒÖc': 'Najnowsze/Ostatni miesiƒÖc',
            'ostatni_rok': 'Ostatni rok',
            'starszy': 'Starsze pliki',
            'nieznana': 'Data nieznana'
        }

        return date_mapping.get(date_category, 'Data nieznana')

    def _get_dynamic_folder(self, file_info):
        """NOWA: Zwraca nazwƒô folderu na podstawie dynamicznych kategorii - Windows compatible"""
        # Sprawd≈∫ najpierw proste wzorce
        if hasattr(file_info, 'category_name') and file_info.category_name:
            for category in file_info.category_name:
                if category in self.dynamic_folder_mapping:
                    return self.dynamic_folder_mapping[category]

                # Sprawd≈∫ dynamiczne kategorie - BEZ DWUKROPKA dla Windows!
                if category.startswith('grupa_'):
                    group_name = category.replace('grupa_', '').title()
                    return f"Grupa {group_name}"  # Usuniƒôto dwukropek
                elif category.startswith('seria_'):
                    series_name = category.replace('seria_', '').title()
                    return f"Seria {series_name}"  # Usuniƒôto dwukropek
                elif category.startswith('temat_'):
                    theme_name = category.replace('temat_', '').title()
                    return f"Temat {theme_name}"  # Usuniƒôto dwukropek
                elif category.startswith('typ_'):
                    type_name = category.replace('typ_', '').title()
                    return f"Typ {type_name}"  # Usuniƒôto dwukropek

        # Sprawd≈∫ wzorce czasowe
        if hasattr(file_info, 'time_pattern_categories') and file_info.time_pattern_categories:
            if 'dzienny' in file_info.time_pattern_categories:
                return "Pliki Dzienne"
            elif 'miesiƒôczny' in file_info.time_pattern_categories:
                return "Pliki Miesiƒôczne"
            elif 'roczny' in file_info.time_pattern_categories:
                return "Pliki Roczne"

        return None  # Brak dynamicznej kategorii

    def create_folders_and_move_files(self, file_mapping, dry_run=False, use_existing_structure=True):
        """
        Tworzy foldery i przenosi pliki zgodnie z mapowaniem
        """
        print(f"\n=== {'SYMULACJA' if dry_run else 'WYKONANIE'} PRZENOSZENIA ===")
        print(f"U≈ºywanie istniejƒÖcej struktury: {'TAK' if use_existing_structure else 'NIE'}")

        results = {
            'success': [],
            'failed': [],
            'folders_created': set(),
            'folders_reused': set(),
            'skipped': []
        }

        # Je≈õli w≈ÇƒÖczona jest opcja u≈ºywania istniejƒÖcej struktury, przeanalizuj istniejƒÖce foldery
        if use_existing_structure:
            existing_structure = self._analyze_existing_structure(file_mapping)
            print(f"\nüìÅ ISTNIEJƒÑCA STRUKTURA:")
            for folder_type, paths in existing_structure.items():
                if paths:
                    print(f"  {folder_type}: {len(paths)} istniejƒÖcych folder√≥w")
        else:
            existing_structure = {}

        for source_path, target_path in file_mapping.items():
            try:
                # Sprawd≈∫ czy plik ≈∫r√≥d≈Çowy istnieje
                if not os.path.exists(source_path):
                    results['failed'].append({
                        'source': source_path,
                        'target': target_path,
                        'error': 'Plik ≈∫r√≥d≈Çowy nie istnieje'
                    })
                    continue

                # Dostosuj ≈õcie≈ºkƒô docelowƒÖ do istniejƒÖcej struktury (je≈õli w≈ÇƒÖczone)
                if use_existing_structure:
                    target_path = self._adapt_to_existing_structure(target_path, existing_structure)

                # Utw√≥rz folder docelowy
                target_dir = os.path.dirname(target_path)
                folder_existed = os.path.exists(target_dir)

                if not dry_run:
                    if not folder_existed:
                        os.makedirs(target_dir, exist_ok=True)
                        results['folders_created'].add(target_dir)
                        print(f"  üìÅ Utworzono nowy folder: {os.path.relpath(target_dir)}")
                    else:
                        results['folders_reused'].add(target_dir)
                        print(f"  ‚ôªÔ∏è  U≈ºyto istniejƒÖcego folderu: {os.path.relpath(target_dir)}")
                else:
                    if not folder_existed:
                        results['folders_created'].add(target_dir)
                        print(f"  üìÅ [SYMULACJA] Utworzƒô folder: {os.path.relpath(target_dir)}")
                    else:
                        results['folders_reused'].add(target_dir)
                        print(f"  ‚ôªÔ∏è  [SYMULACJA] U≈ºyjƒô istniejƒÖcego: {os.path.relpath(target_dir)}")

                # Sprawd≈∫ czy plik docelowy ju≈º istnieje
                if os.path.exists(target_path):
                    # Generuj unikalnƒÖ nazwƒô
                    base, ext = os.path.splitext(target_path)
                    counter = 1

                    while os.path.exists(f"{base} ({counter}){ext}"):
                        counter += 1

                    target_path = f"{base} ({counter}){ext}"
                    print(f"  üîÑ Zmieniono nazwƒô na: {os.path.basename(target_path)}")

                # Przenie≈õ plik
                if not dry_run:
                    shutil.move(source_path, target_path)
                    print(f"  ‚úÖ Przeniesiono: {os.path.basename(source_path)} -> {os.path.relpath(target_path)}")
                else:
                    print(
                        f"  ‚úÖ [SYMULACJA] Przeniosƒô: {os.path.basename(source_path)} -> {os.path.relpath(target_path)}")

                results['success'].append({
                    'source': source_path,
                    'target': target_path,
                    'file_name': os.path.basename(source_path),
                    'folder_reused': folder_existed
                })

            except Exception as e:
                error_msg = f"B≈ÇƒÖd przenoszenia {source_path}: {e}"
                print(f"  ‚ùå B≈ÅƒÑD: {error_msg}")
                traceback.print_exc()

                results['failed'].append({
                    'source': source_path,
                    'target': target_path,
                    'error': str(e)
                })

        # Podsumowanie
        print(f"\n=== PODSUMOWANIE ===")
        print(f"Pomy≈õlnie przeniesione: {len(results['success'])}")
        print(f"B≈Çƒôdy: {len(results['failed'])}")
        print(f"Nowe foldery: {len(results['folders_created'])}")
        print(f"Ponownie u≈ºyte foldery: {len(results['folders_reused'])}")

        return results

    def analyze_folder_structure(self, files_info_list, organization_mode="full"):
        """Analizuje jak bƒôdzie wyglƒÖdaƒá struktura folder√≥w bez tworzenia"""
        folder_preview = defaultdict(list)

        for file_info in files_info_list:
            # Symuluj ≈õcie≈ºkƒô
            fake_base = "/example"
            target_path = self._generate_file_path(fake_base, file_info, organization_mode)

            # WyciƒÖgnij ≈õcie≈ºkƒô wzglƒôdnƒÖ folderu
            relative_folder = os.path.dirname(os.path.relpath(target_path, fake_base))
            folder_preview[relative_folder].append(file_info.name + file_info.extension)

        return dict(folder_preview)

    def analyze_folder_structure_custom(self, files_info_list, hierarchy_levels):
        """Analizuje jak bƒôdzie wyglƒÖdaƒá struktura folder√≥w dla niestandardowej hierarchii"""
        folder_preview = defaultdict(list)

        for file_info in files_info_list:
            # Symuluj ≈õcie≈ºkƒô
            fake_base = "/example"
            target_path = self._generate_file_path_custom(fake_base, file_info, hierarchy_levels)

            # WyciƒÖgnij ≈õcie≈ºkƒô wzglƒôdnƒÖ folderu
            relative_folder = os.path.dirname(os.path.relpath(target_path, fake_base))
            folder_preview[relative_folder].append(file_info.name + file_info.extension)

        return dict(folder_preview)

    def _analyze_existing_structure(self, file_mapping):
        """Analizuje istniejƒÖcƒÖ strukturƒô folder√≥w w lokalizacji docelowej"""
        existing_structure = {
            'main_folders': {},  # typ_pliku -> lista_istniejƒÖcych_folder√≥w
            'date_folders': {},  # rok -> lista_miesiƒôcy
            'dynamic_folders': {},  # kategoria_dynamiczna -> lista_folder√≥w
        }

        # Zbierz wszystkie unikalne ≈õcie≈ºki bazowe
        base_paths = set()
        for target_path in file_mapping.values():
            # Znajd≈∫ g≈Ç√≥wny folder organizacji (zazwyczaj 2-3 poziomy w g√≥rƒô)
            parts = target_path.split(os.sep)
            if len(parts) >= 3:
                base_path = os.sep.join(parts[:-3])  # usu≈Ñ ostatnie 3 czƒô≈õci ≈õcie≈ºki
                base_paths.add(base_path)

        # Analizuj ka≈ºdƒÖ ≈õcie≈ºkƒô bazowƒÖ
        for base_path in base_paths:
            if not os.path.exists(base_path):
                continue

            try:
                # Znajd≈∫ g≈Ç√≥wne foldery typu pliku (z ikonami emoji)
                for item in os.listdir(base_path):
                    item_path = os.path.join(base_path, item)
                    if os.path.isdir(item_path):
                        # Sprawd≈∫ czy to folder g≈Ç√≥wnego typu (zawiera emoji)
                        if any(emoji in item for emoji in ['üìÑ', 'üñºÔ∏è', 'üéµ', 'üé¨', 'üíª', 'üìä', 'üì¶', 'üé®']):
                            folder_type = item
                            existing_structure['main_folders'][folder_type] = []

                            # Znajd≈∫ podfoldery z datami
                            self._scan_date_folders(item_path, existing_structure, folder_type)

                print(f"Znaleziono g≈Ç√≥wne foldery: {list(existing_structure['main_folders'].keys())}")
            except Exception as e:
                print(f"B≈ÇƒÖd analizy struktury w {base_path}: {e}")

        return existing_structure

    def _scan_date_folders(self, main_folder_path, existing_structure, folder_type):
        """Skanuje foldery z datami w g≈Ç√≥wnym folderze typu pliku"""
        try:
            for item in os.listdir(main_folder_path):
                item_path = os.path.join(main_folder_path, item)
                if os.path.isdir(item_path):
                    # Sprawd≈∫ czy to folder z rokiem (4 cyfry)
                    if item.isdigit() and len(item) == 4:
                        year_folder = item
                        existing_structure['date_folders'][year_folder] = []

                        # Znajd≈∫ foldery miesiƒôcy
                        year_path = item_path
                        try:
                            for month_item in os.listdir(year_path):
                                month_path = os.path.join(year_path, month_item)
                                if os.path.isdir(month_path):
                                    # Format: "MM - MonthName"
                                    if " - " in month_item and month_item[:2].isdigit():
                                        existing_structure['date_folders'][year_folder].append(month_item)

                                        # Znajd≈∫ foldery dynamiczne w miesiƒÖcu
                                        self._scan_dynamic_folders(month_path, existing_structure)
                        except OSError:
                            pass

                    # Sprawd≈∫ inne mo≈ºliwe foldery daty
                    elif item in ['Najnowsze', 'Data nieznana', 'Ostatni rok', 'Starsze pliki']:
                        existing_structure['date_folders'][item] = []
                        self._scan_dynamic_folders(item_path, existing_structure)

        except OSError as e:
            print(f"B≈ÇƒÖd skanowania folder√≥w dat w {main_folder_path}: {e}")

    def _scan_dynamic_folders(self, date_folder_path, existing_structure):
        """Skanuje dynamiczne foldery w folderze daty"""
        try:
            for item in os.listdir(date_folder_path):
                item_path = os.path.join(date_folder_path, item)
                if os.path.isdir(item_path):
                    # To jest folder dynamiczny
                    dynamic_name = item
                    if dynamic_name not in existing_structure['dynamic_folders']:
                        existing_structure['dynamic_folders'][dynamic_name] = []
                    existing_structure['dynamic_folders'][dynamic_name].append(item_path)

        except OSError as e:
            print(f"B≈ÇƒÖd skanowania folder√≥w dynamicznych w {date_folder_path}: {e}")

    def _adapt_to_existing_structure(self, target_path, existing_structure):
        """Dostosowuje ≈õcie≈ºkƒô docelowƒÖ do istniejƒÖcej struktury folder√≥w"""
        if not existing_structure:
            return target_path

        path_parts = target_path.split(os.sep)
        adapted_parts = path_parts.copy()

        # Sprawd≈∫ czy mo≈ºna dostosowaƒá g≈Ç√≥wny folder typu
        for i, part in enumerate(path_parts):
            if any(emoji in part for emoji in ['üìÑ', 'üñºÔ∏è', 'üéµ', 'üé¨', 'üíª', 'üìä', 'üì¶', 'üé®']):
                # Sprawd≈∫ czy istnieje podobny folder
                for existing_main in existing_structure['main_folders'].keys():
                    # Dopasowanie na podstawie zawarto≈õci (bez ikon mo≈ºe siƒô r√≥≈ºniƒá)
                    if self._folders_are_similar(part, existing_main):
                        adapted_parts[i] = existing_main
                        print(f"  üîÑ Dostosowano g≈Ç√≥wny folder: {part} -> {existing_main}")
                        break
                break

        # Sprawd≈∫ czy mo≈ºna dostosowaƒá folder daty
        for i, part in enumerate(path_parts):
            if part.isdigit() and len(part) == 4:  # Folder roku
                if part in existing_structure['date_folders']:
                    # Rok istnieje, sprawd≈∫ miesiƒÖc
                    if i + 1 < len(path_parts):
                        month_part = path_parts[i + 1]
                        existing_months = existing_structure['date_folders'][part]

                        # Znajd≈∫ podobny miesiƒÖc
                        for existing_month in existing_months:
                            if month_part in existing_month or existing_month in month_part:
                                adapted_parts[i + 1] = existing_month
                                print(f"  üîÑ Dostosowano miesiƒÖc: {month_part} -> {existing_month}")
                                break
                break

        # Sprawd≈∫ foldery dynamiczne
        for i, part in enumerate(path_parts):
            if part in existing_structure['dynamic_folders']:
                print(f"  üîÑ Znaleziono istniejƒÖcy folder dynamiczny: {part}")
                # Folder dynamiczny ju≈º istnieje, nie trzeba zmieniaƒá
                break
            else:
                # Sprawd≈∫ podobne foldery dynamiczne
                for existing_dynamic in existing_structure['dynamic_folders'].keys():
                    if self._folders_are_similar(part, existing_dynamic):
                        adapted_parts[i] = existing_dynamic
                        print(f"  üîÑ Dostosowano folder dynamiczny: {part} -> {existing_dynamic}")
                        break

        adapted_path = os.sep.join(adapted_parts)

        if adapted_path != target_path:
            print(f"  üìÅ ≈öcie≈ºka dostosowana do istniejƒÖcej struktury")

        return adapted_path

    def _folders_are_similar(self, folder1, folder2):
        """Sprawdza czy dwa foldery sƒÖ podobne (ignoruje ikony emoji)"""
        # Usu≈Ñ emoji i znaki specjalne
        import re
        clean1 = re.sub(r'[^\w\s]', '', folder1).strip().lower()
        clean2 = re.sub(r'[^\w\s]', '', folder2).strip().lower()

        # Sprawd≈∫ podobie≈Ñstwo
        if clean1 == clean2:
            return True

        # Sprawd≈∫ czy jeden zawiera drugi
        if clean1 in clean2 or clean2 in clean1:
            return True

        # Sprawd≈∫ podobie≈Ñstwo s≈Ç√≥w kluczowych
        keywords1 = set(clean1.split())
        keywords2 = set(clean2.split())

        if keywords1 & keywords2:  # MajƒÖ wsp√≥lne s≈Çowa
            return True

        return False

    def get_organization_modes(self):
        """Zwraca dostƒôpne tryby organizacji z opisami - PRZESTARZA≈ÅE, u≈ºywaj custom hierarchy"""
        # Ta metoda jest zachowana dla kompatybilno≈õci wstecznej
        # Nowy system u≈ºywa niestandardowych hierarchii
        return {
            "simple": {
                "name": "Prosty",
                "description": "Tylko wed≈Çug typu pliku (Dokumenty, Zdjƒôcia, itp.)",
                "example": "üìÑ Dokumenty/dokument.pdf"
            },
            "by_date": {
                "name": "Z datƒÖ",
                "description": "Typ pliku + rok i miesiƒÖc",
                "example": "üìÑ Dokumenty/2024/03 - March/dokument.pdf"
            },
            "full": {
                "name": "Pe≈Çny",
                "description": "Typ pliku + data + dynamiczne kategorie",
                "example": "üìÑ Dokumenty/2024/03 - March/Seria: Umowy/dokument.pdf"
            },
            "theme_first": {
                "name": "Dynamiczne pierwsza",
                "description": "Dynamiczne kategorie + typ pliku + data",
                "example": "Seria: Umowy/üìÑ Dokumenty/2024/03 - March/dokument.pdf"
            }
        }